#!/usr/bin/env python3
import os
import sys
import json
import asyncio
import getpass
from dotenv import load_dotenv, set_key
import datetime
import logging
from typing import Dict, List, Optional, Any, Union
import argparse
import random

from core.meme_generator import MemeGenerator

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger('meme_generator')

# Load environment variables
load_dotenv()

# Default text if OpenAI is not configured
DEFAULT_TEXT = "Quand le dev junior d√©ploie son code sans tests"

# Environment file path
ENV_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env')

async def ensure_openai_api_key() -> str:
    """
    Ensures a valid OpenAI API key is configured
    
    Returns:
        str: The OpenAI API key
    """
    api_key = os.getenv('OPENAI_API_KEY')
    
    if not api_key or api_key == 'your_openai_api_key_here' or 'your_' in api_key:
        logger.warning("‚ö†Ô∏è No valid OpenAI API key found in .env file")
        logger.info("To generate punchlines, you must provide a valid OpenAI API key.")
        api_key = getpass.getpass("Enter your OpenAI API key: ")
        
        if not api_key:
            raise ValueError("No OpenAI API key provided. Cannot generate a punchline.")
        
        # Update .env file with the new API key
        set_key(ENV_PATH, 'OPENAI_API_KEY', api_key)
        os.environ['OPENAI_API_KEY'] = api_key
        logger.info("‚úÖ OpenAI API key saved to .env file")
    
    return api_key

async def generate_meme(
    custom_text: Optional[str] = None, 
    subject: Optional[str] = None, 
    economy_mode: Optional[bool] = None, 
    send_to_telegram: Optional[bool] = None
) -> Dict[str, Any]:
    """
    Generates an 'L'ARROGANCE!' video meme with a punchline generated by GPT-4
    
    Args:
        custom_text: Custom text to use (ignored if not None)
        subject: The subject on which to generate a punchline
        economy_mode: Enable token economy mode
        send_to_telegram: Force sending or not to Telegram
        
    Returns:
        Dict containing the generated meme information
    """
    try:
        logger.info("üé¨ Starting 'L'ARROGANCE!' meme generator...")
        
        # Ensure a valid OpenAI API key is configured if needed
        if not custom_text:
            await ensure_openai_api_key()
        
        # Initialize the meme generator
        meme_generator = MemeGenerator()
        
        if custom_text:
            logger.info(f"üìù Using custom text: \"{custom_text}\"")
            result = await meme_generator.generate_meme(
                custom_text=custom_text, 
                send_to_telegram=send_to_telegram
            )
        else:
            # Use OpenAI to generate a punchline with the specified subject
            if subject:
                logger.info(f"ü§ñ Generating a punchline with OpenAI on subject: \"{subject}\"")
            else:
                logger.info(f"ü§ñ Generating a punchline with OpenAI on default subject")
            
            # Display the mode used
            if economy_mode:
                logger.info("üí∞ Economy mode enabled: using GPT-3.5-turbo with simplified prompt")
            
            result = await meme_generator.generate_meme(
                subject=subject, 
                economy_mode=economy_mode, 
                send_to_telegram=send_to_telegram
            )
        
        logger.info(f"‚úÖ Meme generated successfully!")
        logger.info(f"üìù Text: {result['text']}")
        logger.info(f"üé• Video: {result['video_path']}")
        
        return result
    except Exception as e:
        logger.error(f"‚ùå Error generating meme: {str(e)}")
        raise e

async def generate_batch_memes(
    json_file_path: str, 
    economy_mode: Optional[bool] = None, 
    limit: Optional[int] = None, 
    send_to_telegram: Optional[bool] = None
) -> List[Dict[str, Any]]:
    """
    G√©n√®re des m√®mes par lots √† partir d'un fichier JSON contenant des sujets
    
    Args:
        json_file_path: Chemin vers le fichier JSON contenant les sujets
        economy_mode: Utiliser le mode √©conomie (GPT-3.5 au lieu de GPT-4)
        limit: Nombre maximum de m√®mes √† g√©n√©rer
        send_to_telegram: Envoyer les m√®mes sur Telegram
        
    Returns:
        Liste des r√©sultats de g√©n√©ration
    """
    # V√©rifier si le fichier existe
    if not os.path.exists(json_file_path):
        # Try to find the file in the data directory
        data_dir_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')
        alternative_path = os.path.join(data_dir_path, os.path.basename(json_file_path))
        if os.path.exists(alternative_path):
            json_file_path = alternative_path
        else:
            raise FileNotFoundError(f"Le fichier JSON {json_file_path} n'existe pas.")
    
    # Charger le fichier JSON
    with open(json_file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    # Extraire les sujets
    all_subjects = []
    if 'sujets' in data:
        all_subjects = data['sujets']
    elif 'subjects' in data:
        all_subjects = data['subjects']
    elif 'sujets_clivants' in data:
        all_subjects = data['sujets_clivants']
    
    if not all_subjects:
        raise ValueError("Aucun sujet trouv√© dans le fichier JSON.")
    
    # Chemin du fichier de suivi des sujets utilis√©s
    used_subjects_path = os.path.join(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
        'output',
        'used_subjects.json'
    )
    
    # Charger les sujets d√©j√† utilis√©s
    used_subjects = []
    if os.path.exists(used_subjects_path):
        try:
            with open(used_subjects_path, 'r', encoding='utf-8') as f:
                used_subjects_data = json.load(f)
                used_subjects = used_subjects_data.get('used_subjects', [])
        except json.JSONDecodeError:
            logger.warning("‚ùå Fichier de sujets utilis√©s corrompu. Cr√©ation d'un nouveau fichier.")
            used_subjects = []
    
    # Filtrer les sujets non utilis√©s
    available_subjects = [s for s in all_subjects if s not in used_subjects]
    
    # Si tous les sujets ont √©t√© utilis√©s, r√©initialiser la liste
    if not available_subjects:
        logger.info("üîÑ Tous les sujets ont √©t√© utilis√©s. R√©initialisation de la liste.")
        available_subjects = all_subjects.copy()
        used_subjects = []
    
    # S√©lectionner al√©atoirement les sujets
    num_to_select = min(limit if limit else 1, len(available_subjects))
    selected_subjects = random.sample(available_subjects, num_to_select)
    
    logger.info(f"üé≤ S√©lection al√©atoire de {num_to_select} sujets parmi {len(available_subjects)} disponibles.")
    
    # Initialiser le g√©n√©rateur de m√®mes
    meme_generator = MemeGenerator()
    
    # G√©n√©rer les m√®mes pour chaque sujet
    results = []
    for subject in selected_subjects:
        logger.info(f"üéØ G√©n√©ration d'un m√®me sur le sujet: {subject}")
        result = await meme_generator.generate_meme(
            subject=subject,
            economy_mode=economy_mode,
            send_to_telegram=send_to_telegram
        )
        results.append(result)
        
        # Ajouter le sujet √† la liste des sujets utilis√©s
        used_subjects.append(subject)
    
    # Enregistrer les sujets utilis√©s
    os.makedirs(os.path.dirname(used_subjects_path), exist_ok=True)
    with open(used_subjects_path, 'w', encoding='utf-8') as f:
        json.dump({
            'last_updated': datetime.datetime.now().isoformat(),
            'used_subjects': used_subjects
        }, f, ensure_ascii=False, indent=2)
    
    # Generate a JSON report of generated memes
    if results:
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        report_path = os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
            'output',
            'reports',
            f'batch_report_{timestamp}.json'
        )
        
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump({
                'timestamp': timestamp,
                'total_subjects': len(all_subjects),
                'available_subjects': len(available_subjects),
                'used_subjects': len(used_subjects),
                'generated_memes': len(results),
                'results': results
            }, f, ensure_ascii=False, indent=2)
        
        logger.info(f"üìù Rapport de g√©n√©ration par lots enregistr√©: {report_path}")
    
    return results

def set_economy_mode_in_env(value: bool) -> None:
    """
    Sets the default economy mode in the .env file
    
    Args:
        value: True to enable economy mode, False to disable
    """
    set_key(ENV_PATH, 'ECONOMY_MODE', str(value).lower())
    os.environ['ECONOMY_MODE'] = str(value).lower()
    logger.info(f"‚úÖ Mode √©conomie {'activ√©' if value else 'd√©sactiv√©'} par d√©faut dans .env")

def set_telegram_auto_send_in_env(value: bool) -> None:
    """
    Sets the default automatic sending to Telegram in the .env file
    
    Args:
        value: True to enable automatic sending, False to disable
    """
    set_key(ENV_PATH, 'TELEGRAM_AUTO_SEND', str(value).lower())
    os.environ['TELEGRAM_AUTO_SEND'] = str(value).lower()
    logger.info(f"‚úÖ Envoi automatique sur Telegram {'activ√©' if value else 'd√©sactiv√©'} par d√©faut dans .env")

def parse_arguments() -> Dict[str, Any]:
    """
    Parse command line arguments
    
    Returns:
        Dictionary of parsed arguments
    """
    parser = argparse.ArgumentParser(description='G√©n√©rateur de m√®mes "L\'ARROGANCE!"')
    
    # Groupe d'options mutuellement exclusives pour le texte
    text_group = parser.add_mutually_exclusive_group()
    text_group.add_argument('-t', '--text', type=str, help='Texte personnalis√© pour le m√®me')
    text_group.add_argument('-s', '--subject', type=str, help='Sujet pour g√©n√©rer une punchline')
    text_group.add_argument('-b', '--batch', type=str, help='Chemin vers un fichier JSON contenant des sujets')
    
    # Options suppl√©mentaires
    parser.add_argument('-e', '--economy', action='store_true', help='Activer le mode √©conomie de tokens (GPT-3.5 au lieu de GPT-4)')
    parser.add_argument('--telegram', action='store_true', help='Envoyer le m√®me sur Telegram')
    parser.add_argument('-l', '--limit', type=int, help='Limiter le nombre de m√®mes g√©n√©r√©s en mode batch')
    
    args = parser.parse_args()
    
    # V√©rifier si aucune option n'est sp√©cifi√©e
    if not args.text and not args.subject and not args.batch:
        # Utiliser le fichier JSON par d√©faut
        default_json = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data', 'json.json')
        if os.path.exists(default_json):
            logger.info(f"üîÑ Aucun sujet sp√©cifi√©, utilisation du fichier par d√©faut: {default_json}")
            args.batch = default_json
        else:
            # Utiliser le sujet par d√©faut
            logger.info("üîÑ Aucun sujet sp√©cifi√©, utilisation du sujet par d√©faut")
            args.subject = "L'arrogance des d√©veloppeurs"
    
    # Convertir les arguments en dictionnaire
    return {
        'custom_text': args.text,
        'subject': args.subject,
        'batch_file': args.batch,
        'economy_mode': args.economy,
        'send_to_telegram': args.telegram,
        'limit': args.limit
    }

async def main() -> None:
    """
    Main function
    """
    try:
        # Parse command line arguments
        args = parse_arguments()
        
        # Ensure a valid OpenAI API key is configured
        await ensure_openai_api_key()
        
        # Set default economy mode if requested
        if args.get('set_default_economy', False):
            set_economy_mode_in_env(args['economy_mode'])
        
        # Set default Telegram auto-send if requested
        if args.get('set_default_telegram', False):
            set_telegram_auto_send_in_env(args['send_to_telegram'])
        
        # Generate meme based on arguments
        if args['batch_file']:
            # Batch generation from JSON file
            logger.info(f"üì¶ G√©n√©ration par lots √† partir du fichier: {args['batch_file']}")
            results = await generate_batch_memes(
                args['batch_file'],
                economy_mode=args['economy_mode'],
                limit=args['limit'],
                send_to_telegram=args['send_to_telegram']
            )
            logger.info(f"‚úÖ {len(results)} m√®mes g√©n√©r√©s avec succ√®s!")
            
        elif args['custom_text']:
            # Generate meme with custom text
            logger.info(f"üé¨ G√©n√©ration d'un m√®me avec le texte personnalis√©: {args['custom_text']}")
            result = await generate_meme(
                custom_text=args['custom_text'],
                economy_mode=args['economy_mode'],
                send_to_telegram=args['send_to_telegram']
            )
            logger.info(f"‚úÖ M√®me g√©n√©r√© avec succ√®s: {result['video_path']}")
            
        else:
            # Generate meme with subject
            subject = args['subject'] or "L'arrogance des d√©veloppeurs"
            logger.info(f"üé¨ G√©n√©ration d'un m√®me sur le sujet: {subject}")
            result = await generate_meme(
                subject=subject,
                economy_mode=args['economy_mode'],
                send_to_telegram=args['send_to_telegram']
            )
            logger.info(f"‚úÖ M√®me g√©n√©r√© avec succ√®s: {result['video_path']}")
            logger.info(f"üìù Texte: {result['text']}")
        
    except Exception as e:
        logger.error(f"‚ùå Erreur: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("\n‚ö†Ô∏è Operation cancelled by user")
        sys.exit(0)
    except Exception as e:
        logger.error(f"‚ùå Fatal error: {str(e)}")
        sys.exit(1) 